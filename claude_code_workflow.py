#!/usr/bin/env python3
"""
Claude Code Workflow for EPUB to Anki conversion.

This script is designed to be used WITH Claude Code (not the API).
Claude Code reads the EPUB, generates flashcards in conversation,
and this script handles the export to Anki format.

Usage (from within Claude Code):
    1. Ask Claude Code to run: python claude_code_workflow.py parse /path/to/book.epub
    2. Claude Code will read chapters and generate flashcards
    3. Ask Claude Code to run: python claude_code_workflow.py export
"""

import json
import sys
from pathlib import Path

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent / "src"))

from epub_to_anki.parser import parse_epub
from epub_to_anki.parser.epub_parser import get_book_summary
from epub_to_anki.exporter import AnkiExporter
from epub_to_anki.models import (
    Card, CardFormat, CardType, CardStatus,
    Chapter, ChapterCards, Density, DeckConfig
)


# Session state file
STATE_FILE = Path(__file__).parent / ".claude_session.json"


def parse_command(epub_path: str, extract_images: bool = False):
    """Parse an EPUB and save session state for Claude Code to work with."""
    book = parse_epub(epub_path, extract_images=extract_images)

    # Save state
    state = {
        "epub_path": epub_path,
        "title": book.title,
        "author": book.author,
        "chapters": [
            {
                "index": ch.index,
                "title": ch.title,
                "word_count": ch.word_count,
                "content": ch.content,
            }
            for ch in book.chapters
        ],
        "cards": [],  # Claude Code will populate this
        "current_chapter": 0,
    }

    STATE_FILE.write_text(json.dumps(state, indent=2))

    # Print summary for Claude Code
    print(get_book_summary(book))
    print(f"\n✓ Session saved to {STATE_FILE}")
    print(f"\nTo generate flashcards, ask Claude Code to read chapters and create cards.")
    print(f"Then run: python claude_code_workflow.py export")


def show_chapter(chapter_index: int = None):
    """Show a specific chapter's content for Claude Code to process."""
    if not STATE_FILE.exists():
        print("No session found. Run 'parse' first.")
        return

    state = json.loads(STATE_FILE.read_text())

    if chapter_index is None:
        chapter_index = state.get("current_chapter", 0)

    if chapter_index >= len(state["chapters"]):
        print(f"Chapter {chapter_index} doesn't exist. Book has {len(state['chapters'])} chapters.")
        return

    chapter = state["chapters"][chapter_index]
    print(f"\n{'='*60}")
    print(f"CHAPTER {chapter['index'] + 1}: {chapter['title']}")
    print(f"Words: {chapter['word_count']}")
    print(f"{'='*60}\n")
    print(chapter["content"])
    print(f"\n{'='*60}")
    print(f"End of Chapter {chapter['index'] + 1}")
    print(f"{'='*60}")


def add_cards(cards_json: str):
    """Add cards generated by Claude Code to the session."""
    if not STATE_FILE.exists():
        print("No session found. Run 'parse' first.")
        return

    state = json.loads(STATE_FILE.read_text())

    try:
        new_cards = json.loads(cards_json)
        if isinstance(new_cards, list):
            state["cards"].extend(new_cards)
        else:
            state["cards"].append(new_cards)

        STATE_FILE.write_text(json.dumps(state, indent=2))
        print(f"✓ Added {len(new_cards) if isinstance(new_cards, list) else 1} cards")
        print(f"Total cards: {len(state['cards'])}")
    except json.JSONDecodeError as e:
        print(f"Error parsing cards JSON: {e}")


def export_command(output_path: str = None, threshold: float = 5.0):
    """Export cards to Anki .apkg format."""
    if not STATE_FILE.exists():
        print("No session found. Run 'parse' first.")
        return

    state = json.loads(STATE_FILE.read_text())

    if not state["cards"]:
        print("No cards to export. Generate cards first.")
        return

    # Set up output
    safe_title = "".join(c if c.isalnum() or c in " -_" else "_" for c in state["title"])
    if output_path:
        output_dir = Path(output_path)
    else:
        output_dir = Path(__file__).parent / "output" / safe_title

    output_dir.mkdir(parents=True, exist_ok=True)

    # Convert JSON cards to Card objects
    cards = []
    for i, card_data in enumerate(state["cards"]):
        try:
            card_format = CardFormat(card_data.get("format", "qa"))
            card_type = CardType(card_data.get("card_type", "concept"))

            # Get score and apply threshold
            importance = card_data.get("importance", 5)
            difficulty = card_data.get("difficulty", 5)
            score = (importance * 2 + difficulty) / 3
            status = CardStatus.INCLUDED if score >= threshold else CardStatus.EXCLUDED

            card = Card(
                id=f"card_{i:04d}",
                format=card_format,
                card_type=card_type,
                question=card_data.get("question"),
                answer=card_data.get("answer"),
                cloze_text=card_data.get("cloze_text"),
                importance=importance,
                difficulty=difficulty,
                source_chapter=card_data.get("source_chapter", "Unknown"),
                source_chapter_index=card_data.get("source_chapter_index", 0),
                source_section=card_data.get("source_section"),
                status=status,
                tags=card_data.get("tags", []),
            )
            cards.append(card)
        except Exception as e:
            print(f"Warning: Skipping card {i}: {e}")

    # Export
    deck_name = f"{state['title']} - {state['author']}"
    exporter = AnkiExporter(deck_name)

    included_count = 0
    for card in cards:
        if card.status == CardStatus.INCLUDED:
            exporter.add_card(card)
            included_count += 1

    apkg_path = output_dir / f"{safe_title}.apkg"
    exporter.export(apkg_path)

    # Save JSON backup
    included_json = output_dir / "cards.json"
    included_json.write_text(json.dumps(state["cards"], indent=2))

    print(f"\n✓ Exported {included_count} cards to: {apkg_path}")
    print(f"✓ JSON backup saved to: {included_json}")
    print(f"\nImport {apkg_path} into Anki to use your flashcards!")


def status_command():
    """Show current session status."""
    if not STATE_FILE.exists():
        print("No active session.")
        print("Start with: python claude_code_workflow.py parse /path/to/book.epub")
        return

    state = json.loads(STATE_FILE.read_text())
    print(f"\nBook: {state['title']} by {state['author']}")
    print(f"Chapters: {len(state['chapters'])}")
    print(f"Cards generated: {len(state['cards'])}")

    if state['cards']:
        formats = {}
        for card in state['cards']:
            fmt = card.get('format', 'unknown')
            formats[fmt] = formats.get(fmt, 0) + 1
        print(f"Card types: {formats}")


def clear_command():
    """Clear the current session."""
    if STATE_FILE.exists():
        STATE_FILE.unlink()
        print("✓ Session cleared")
    else:
        print("No session to clear")


def main():
    if len(sys.argv) < 2:
        print("""
Claude Code EPUB to Anki Workflow
=================================

Commands:
  parse <epub_path>     Parse an EPUB file and start a session
  chapter [num]         Show chapter content (for Claude Code to read)
  add '<json>'          Add cards (Claude Code generates these)
  export [output_dir]   Export cards to Anki .apkg
  status                Show session status
  clear                 Clear current session

Workflow:
  1. python claude_code_workflow.py parse mybook.epub
  2. Ask Claude Code to read chapters and generate flashcards
  3. python claude_code_workflow.py export
  4. Import the .apkg file into Anki
""")
        return

    command = sys.argv[1].lower()

    if command == "parse":
        if len(sys.argv) < 3:
            print("Usage: python claude_code_workflow.py parse <epub_path>")
            return
        parse_command(sys.argv[2])

    elif command == "chapter":
        idx = int(sys.argv[2]) - 1 if len(sys.argv) > 2 else None
        show_chapter(idx)

    elif command == "add":
        if len(sys.argv) < 3:
            print("Usage: python claude_code_workflow.py add '<json_cards>'")
            return
        add_cards(sys.argv[2])

    elif command == "export":
        output = sys.argv[2] if len(sys.argv) > 2 else None
        export_command(output)

    elif command == "status":
        status_command()

    elif command == "clear":
        clear_command()

    else:
        print(f"Unknown command: {command}")


if __name__ == "__main__":
    main()
